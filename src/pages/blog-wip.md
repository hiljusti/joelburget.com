---
layout: post
title: Blog December XX, 2019
category: post
date: 2019-12-XX
description: Blog December XX, 2019
permalink: /blog-2019-12-XX
listed: False
---

## Some Fibonacci formulas I didn't know

```
fib (n+k) = fib (n-1) * fib k + fib n * fib (k+1)
```

Specialized:

```
fib (2n+1) = (fib (n+1))^2 + (fib n)^2
```

So, you can calculate `fib` in `O(log n)`. From [niche computing science](https://scm.iis.sinica.edu.tw/home/2019/how-to-compute-fibonacci-numbers/).

## [The Credit Assignment Problem](https://www.alignmentforum.org/posts/Ajcq9xWi2fmgn8RBJ/the-credit-assignment-problem)

## Quadratic Payments: A Primer

> an initial foray into a fundamentally new class of social technology which, has the potential to overturn how we make many public decisions, large and small. The ultimate effect of these schemes rolled out in their full form could be as deeply transformative as the industrial-era advent of mostly-free markets and constitutional democracy.

https://vitalik.ca/general/2019/12/07/quadratic.html

## Notes on 'A Small Matter of Programming: Perspectives on End User Computing'

> In other words, natural language interfaces tend towards an uncanny valley. If they don’t have a near-human level of comprehension, the similarity to human language is misleading instead of helpful. The user has no easy way to know what kinds of phrases will lead to the desired results.

> [A] further objection that I rarely see mentioned is one that should be familiar to anyone who has tried to extract a specification from a client - human languages are not well suited to precise descriptions of complex systems. This is the reason why we have mathematics, and why mathemeticians have their own weird pseudo-English.

> Picture the CAD user given a traditional programming language and trying to figure out how to translate their concepts of parts and shapes into bits and pointers. It’s not that they inherently struggle with formal systems, it’s that the system they are presented with is a long way from the problem domain and the mapping between the two is effortful and frustrating.

> Equally relevatory at the time were the numerous examples of formal languages in widespread use. The idea that syntax is the main obstacle to programming completely pervades the programming community, but in this light it’s clearly bunk. People commonly master languages with much crazier syntax (I’m currently learning German, and have to keep reassuring myself that if five year olds can do this so can I).

https://scattered-thoughts.net/blog/2016/06/17/notes-on-a-small-matter-of-programming-perspectives-on-end-user-computing/

## Challenging projects every programmer should try

http://web.eecs.utk.edu/~azh/blog/challengingprojects.html

I really like this list. I've done some but not all of these.

* Text editor
* 2D game - Space Invaders
* Compiler - Tiny BASIC
* Mini operating system
* Spreadsheet
* Video game console emulator

Also, some suggestions from HN, Reddit, Twitter:

* Database from scratch
* Ray tracer
* MS Paint clone
* Vector graphics editor
* Image decoder
* Chatroom web app
* Digits of pi calculator
* Common terminal utilities (e.g., grep)
* FTP client and server

## Tweets

<Tweet tweetLink="andy_matuschak/status/1202663202997170176" />
