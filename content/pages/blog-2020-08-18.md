---
layout: post
title: Blog August 18, 2020
category: post
date: 2020-08-18
description: Blog August 18, 2020
permalink: /blog-2020-08-18
listed: True
---


### [xplain](https://magcius.github.io/xplain/article/index.html)

  - how the X window system works (with demonstrations in the browser)
  - The author does really cool stuff:
      - [noclip.website](https://noclip.website/)
        * "A digital museum of video game levels"
        * Renders levels in the browser using WebGL, you can move around, turn layers on / off, view the textures.
      - [blog.mecheye.net](https://blog.mecheye.net)
      - [How The Wind Waker Defined Cel Shading](https://www.youtube.com/watch?v=mnxs6CR6Zrk) (video)
      - [How scrolling textures gave Super Mario Galaxy 2 its charm](https://www.youtube.com/watch?v=8rCRsOLiO7k) (video)
  - [HN link](https://news.ycombinator.com/item?id=24197528)

### Avionics videos

  - [Avionics bay of a 747-400](https://youtu.be/yq8wgJO-JXY) (from a hacker's perspective)
  - [Avionics bay of an A350](https://youtu.be/LxS2RR-Vx_s)

### MinGPT

  - [github.com/karpathy/minGPT](https://github.com/karpathy/minGPT)
  - [clean transformer implementation](https://github.com/blue-season/pywarm/blob/master/examples/transformer.py)


### [J NOTATION AS A TOOL OF THOUGHT](https://www.hillelwayne.com/post/j-notation/) (Hillel Wayne)


### [From Program Verification to Program Synthesis](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/popl10_synthesis.pdf)

> This paper describes a novel technique for the synthesis of imperative programs. Automated program synthesis has the potential to make programming and the design of systems easier by allowing programs to be specified at a higher-level than executable code. In our approach, which we call proof-theoretic synthesis, the user provides an input-output functional specification, a description of the atomic operations in the programming language, and a specification of the synthesized program's looping structure, allowed stack space, and bound on usage of certain operations. Our technique synthesizes a program, if there exists one, that meets the input-output specification and uses only the given resources.

> The insight behind our approach is to interpret program synthesis as generalized program verification, which allows us to bring verification tools and techniques to program synthesis. Our synthesis algorithm works by creating a program with unknown statements, guards, inductive invariants, and ranking functions. It then generates constraints that relate the unknowns and enforces three kinds of requirements: partial correctness, loop termination, and well-formedness conditions on program guards. We formalize the requirements that program verification tools must meet to solve these constraint and use tools from prior work as our synthesizers.

> We believe the reason for the practicality of our approach is the interplay between the proof (invariants) and the statements. Specifically, by setting up constraints with both statement and proof unknowns together, statements that do not have a corresponding proof are efficiently eliminated. We believe this is the first proposal that leverages this insight for efficient and automatic program synthesis.

### [History for Atheists](https://historyforatheists.com/)

> This blog is for articles, book reviews and critiques relating to “New Atheist Bad History” – the misuse of history and the use of biased, erroneous or distorted pseudo history by anti-theistic atheists. The author **is **an atheist himself so no, this is not some theist apologetics blog. It is simply an attempt to call out and correct the misuse of history, because rationalists should not base their arguments on errors and distortions.

### Ever wondered the difference between yea and yes, or nay and no?

> While Modern English has a __two-form system__ of __yes__ and __no__ for affirmatives and negatives, earlier forms of English had a __four-form system__, comprising the words __yea__, __[nay](https://en.wiktionary.org/wiki/nay#Early_Modern_English)__, __yes__, and __no__. __Yes __contradicts a negatively formulated question, __No__ affirms it; __Yea__ affirms a positively formulated question, __Nay__ contradicts it.

  - Will they not go? — Yes, they will.
  - Will they not go? — No, they will not.
  - Will they go? — Yea, they will.
  - Will they go? — Nay, they will not.”

### [Elementary Tutorial on Normalization-by-Evaluation](http://okmij.org/ftp/tagless-final/NBE.html) (Oleg)


### [Animated Knots](https://www.animatedknots.com/)
### [ITER - the world's largest puzzle](https://www.youtube.com/watch?v=MP2aV26X-70)

  - video about a huge project to create a tokamak fusion reactor

## Tweets

<Tweet tweetLink="sigfpe/status/1295532438400012288" />
<Tweet tweetLink="andy_matuschak/status/1294666980809572352" />
<Tweet tweetLink="vaurorapub/status/1265335071130566656" />
<Tweet tweetLink="math3ma/status/1295808377298223109" />
<Tweet tweetLink="context_ing/status/1293313076268118019" />
<Tweet tweetLink="prathyvsh/status/1287904352078721024" />
<Tweet tweetLink="prathyvsh/status/1295783472494043136" />
<Tweet tweetLink="hillelogram/status/1292609570204979200" />
<Tweet tweetLink="elamje/status/1293321749304614912" />
